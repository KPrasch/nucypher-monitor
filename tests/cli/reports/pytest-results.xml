<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite errors="0" failures="1" hostname="pegasus" name="pytest" skipped="0" tests="1" time="8.526" timestamp="2020-01-17T14:52:36.889923"><testcase classname="tests.cli.test_main" file="tests/cli/test_main.py" line="42" name="test_monitor_crawl_run" time="5.942"><failure message="web3.exceptions.BadFunctionCallOutput: Could not transact with/call contract function, is contract deployed correctly and chain synced?">cls = &lt;class &apos;nucypher.blockchain.eth.agents.ContractAgency&apos;&gt;
agent_class = &lt;class &apos;nucypher.blockchain.eth.agents.StakingEscrowAgent&apos;&gt;
registry = InMemoryContractRegistry(id=6b007a), provider_uri = None

    @classmethod
    def get_agent(cls,
                  agent_class,
                  registry: BaseContractRegistry,
                  provider_uri: str = None,
                  ) -&gt; &apos;EthereumContractAgent&apos;:
    
        if not issubclass(agent_class, EthereumContractAgent):
            raise TypeError(f&quot;Only agent subclasses can be used from the agency.&quot;)
        registry_id = registry.id
        try:
&gt;           return cls.__agents[registry_id][agent_class]
E           KeyError: &apos;6b007a0d52dbf709c4e4064d704a2e7768c029d33708f484e4c86fcf9222636a37bba8b4b54f2aa52b40b896bad820420615e48ad03ec6cce93f3b05cd823e80&apos;

../../../nucypher/nucypher/blockchain/eth/agents.py:61: KeyError

During handling of the above exception, another exception occurred:

web3 = &lt;web3.main.Web3 object at 0x7f169853d3c8&gt;
address = &apos;0xBc6297c0781C25A9Bc44eEe22181C98a30DC0229&apos;, normalizers = ()
function_identifier = &apos;target&apos;
transaction = {&apos;to&apos;: &apos;0xBc6297c0781C25A9Bc44eEe22181C98a30DC0229&apos;}
block_id = &apos;latest&apos;
contract_abi = [{&apos;constant&apos;: True, &apos;inputs&apos;: [], &apos;name&apos;: &apos;previousTarget&apos;, &apos;outputs&apos;: [{&apos;name&apos;: &apos;&apos;, &apos;type&apos;: &apos;address&apos;}], ...}, {&apos;cons...stant&apos;: False, &apos;inputs&apos;: [{&apos;name&apos;: &apos;_testTarget&apos;, &apos;type&apos;: &apos;address&apos;}], &apos;name&apos;: &apos;verifyState&apos;, &apos;outputs&apos;: [], ...}, ...]
fn_abi = {&apos;constant&apos;: True, &apos;inputs&apos;: [], &apos;name&apos;: &apos;target&apos;, &apos;outputs&apos;: [{&apos;name&apos;: &apos;&apos;, &apos;type&apos;: &apos;address&apos;}], ...}
args = (), kwargs = {}
call_transaction = {&apos;data&apos;: &apos;0xd4b83992&apos;, &apos;to&apos;: &apos;0xBc6297c0781C25A9Bc44eEe22181C98a30DC0229&apos;}
return_data = HexBytes(&apos;0x&apos;), output_types = [&apos;address&apos;]
is_missing_code_error = True
msg = &apos;Could not transact with/call contract function, is contract deployed correctly and chain synced?&apos;

    def call_contract_function(
            web3: &apos;Web3&apos;,
            address: ChecksumAddress,
            normalizers: Tuple[Callable[..., Any], ...],
            function_identifier: Union[str, Type[FallbackFn]],
            transaction: TxParams,
            block_id: BlockIdentifier=None,
            contract_abi: ABI=None,
            fn_abi: ABIFunction=None,
            *args: Any,
            **kwargs: Any) -&gt; Sequence[Any]:
        &quot;&quot;&quot;
        Helper function for interacting with a contract function using the
        `eth_call` API.
        &quot;&quot;&quot;
        call_transaction = prepare_transaction(
            address,
            web3,
            fn_identifier=function_identifier,
            contract_abi=contract_abi,
            fn_abi=fn_abi,
            transaction=transaction,
            fn_args=args,
            fn_kwargs=kwargs,
        )
    
        if block_id is None:
            return_data = web3.eth.call(call_transaction)
        else:
            return_data = web3.eth.call(call_transaction, block_identifier=block_id)
    
        if fn_abi is None:
            fn_abi = find_matching_fn_abi(contract_abi, web3.codec, function_identifier, args, kwargs)
    
        output_types = get_abi_output_types(fn_abi)
    
        try:
&gt;           output_data = web3.codec.decode_abi(output_types, return_data)

../../../../.local/share/virtualenvs/nucypher-monitor-Xewuu8ce/lib/python3.7/site-packages/web3/contract.py:1432: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;eth_abi.codec.ABICodec object at 0x7f16985a9b00&gt;, types = [&apos;address&apos;]
data = HexBytes(&apos;0x&apos;)

    def decode_abi(self, types: Iterable[TypeStr], data: Decodable) -&gt; Tuple[Any, ...]:
        &quot;&quot;&quot;
        Decodes the binary value ``data`` as a sequence of values of the ABI types
        in ``types`` via the head-tail mechanism into a tuple of equivalent python
        values.
    
        :param types: An iterable of string representations of the ABI types that
            will be used for decoding e.g. ``(&apos;uint256&apos;, &apos;bytes[]&apos;, &apos;(int,int)&apos;)``
        :param data: The binary value to be decoded.
    
        :returns: A tuple of equivalent python values for the ABI values
            represented in ``data``.
        &quot;&quot;&quot;
        if not is_bytes(data):
            raise TypeError(&quot;The `data` value must be of bytes type.  Got {0}&quot;.format(type(data)))
    
        decoders = [
            self._registry.get_decoder(type_str)
            for type_str in types
        ]
    
        decoder = TupleDecoder(decoders=decoders)
        stream = self.stream_class(data)
    
&gt;       return decoder(stream)

../../../../.local/share/virtualenvs/nucypher-monitor-Xewuu8ce/lib/python3.7/site-packages/eth_abi/codec.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;eth_abi.decoding.TupleDecoder object at 0x7f1697278e48&gt;
stream = &lt;eth_abi.decoding.ContextFramesBytesIO object at 0x7f16971de410&gt;

    def __call__(self, stream: ContextFramesBytesIO) -&gt; Any:
&gt;       return self.decode(stream)

../../../../.local/share/virtualenvs/nucypher-monitor-Xewuu8ce/lib/python3.7/site-packages/eth_abi/decoding.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (&lt;eth_abi.decoding.TupleDecoder object at 0x7f1697278e48&gt;, &lt;eth_abi.decoding.ContextFramesBytesIO object at 0x7f16971de410&gt;)
kwargs = {}

    @functools.wraps(fn)
    def inner(*args, **kwargs) -&gt; T:  # type: ignore
&gt;       return callback(fn(*args, **kwargs))

../../../../.local/share/virtualenvs/nucypher-monitor-Xewuu8ce/lib/python3.7/site-packages/eth_utils/functional.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;eth_abi.decoding.TupleDecoder object at 0x7f1697278e48&gt;
stream = &lt;eth_abi.decoding.ContextFramesBytesIO object at 0x7f16971de410&gt;

    @to_tuple
    def decode(self, stream):
        for decoder in self.decoders:
&gt;           yield decoder(stream)

../../../../.local/share/virtualenvs/nucypher-monitor-Xewuu8ce/lib/python3.7/site-packages/eth_abi/decoding.py:173: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;eth_abi.decoding.AddressDecoder object at 0x7f16985a9c50&gt;
stream = &lt;eth_abi.decoding.ContextFramesBytesIO object at 0x7f16971de410&gt;

    def __call__(self, stream: ContextFramesBytesIO) -&gt; Any:
&gt;       return self.decode(stream)

../../../../.local/share/virtualenvs/nucypher-monitor-Xewuu8ce/lib/python3.7/site-packages/eth_abi/decoding.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;eth_abi.decoding.AddressDecoder object at 0x7f16985a9c50&gt;
stream = &lt;eth_abi.decoding.ContextFramesBytesIO object at 0x7f16971de410&gt;

    def decode(self, stream):
&gt;       raw_data = self.read_data_from_stream(stream)

../../../../.local/share/virtualenvs/nucypher-monitor-Xewuu8ce/lib/python3.7/site-packages/eth_abi/decoding.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;eth_abi.decoding.AddressDecoder object at 0x7f16985a9c50&gt;
stream = &lt;eth_abi.decoding.ContextFramesBytesIO object at 0x7f16971de410&gt;

    def read_data_from_stream(self, stream):
        data = stream.read(self.data_byte_size)
    
        if len(data) != self.data_byte_size:
            raise InsufficientDataBytes(
                &quot;Tried to read {0} bytes.  Only got {1} bytes&quot;.format(
                    self.data_byte_size,
&gt;                   len(data),
                )
            )
E           eth_abi.exceptions.InsufficientDataBytes: Tried to read 32 bytes.  Only got 0 bytes

../../../../.local/share/virtualenvs/nucypher-monitor-Xewuu8ce/lib/python3.7/site-packages/eth_abi/decoding.py:308: InsufficientDataBytes

The above exception was the direct cause of the following exception:

click_runner = &lt;click.testing.CliRunner object at 0x7f1698e0ff98&gt;

    def test_monitor_crawl_run(click_runner):
        crawl_args = (&apos;crawl&apos;, &apos;--dry-run&apos;, &apos;--provider&apos;, &apos;tester://pyevm&apos;)
&gt;       result = click_runner.invoke(monitor_cli, crawl_args, catch_exceptions=False)

test_main.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../.local/share/virtualenvs/nucypher-monitor-Xewuu8ce/lib/python3.7/site-packages/click/testing.py:326: in invoke
    cli.main(args=args or (), prog_name=prog_name, **extra)
../../../../.local/share/virtualenvs/nucypher-monitor-Xewuu8ce/lib/python3.7/site-packages/click/core.py:717: in main
    rv = self.invoke(ctx)
../../../../.local/share/virtualenvs/nucypher-monitor-Xewuu8ce/lib/python3.7/site-packages/click/core.py:1137: in invoke
    return _process_result(sub_ctx.command.invoke(sub_ctx))
../../../../.local/share/virtualenvs/nucypher-monitor-Xewuu8ce/lib/python3.7/site-packages/click/core.py:956: in invoke
    return ctx.invoke(self.callback, **ctx.params)
../../../../.local/share/virtualenvs/nucypher-monitor-Xewuu8ce/lib/python3.7/site-packages/click/core.py:555: in invoke
    return callback(*args, **kwargs)
../../../nucypher/nucypher/cli/options.py:116: in wrapper
    return func(**kwargs)
../../monitor/cli/main.py:90: in crawl
    blockchain_db_port=influx_port)
../../monitor/crawler.py:137: in __init__
    super().__init__(save_metadata=True, node_storage=node_storage, *args, **kwargs)
../../../nucypher/nucypher/network/nodes.py:352: in __init__
    self.remember_node(node, eager=True)
../../../nucypher/nucypher/network/nodes.py:470: in remember_node
    registry=self.registry)  # composed on character subclass, determines operating mode
../../../nucypher/nucypher/network/nodes.py:1194: in verify_node
    self.validate_metadata(registry=registry)
../../../nucypher/nucypher/network/nodes.py:1155: in validate_metadata
    self.validate_worker(registry=registry)
../../../nucypher/nucypher/network/nodes.py:1132: in validate_worker
    if not self._worker_is_bonded_to_staker(registry=registry):  # &lt;-- Blockchain CALL
../../../nucypher/nucypher/network/nodes.py:1083: in _worker_is_bonded_to_staker
    staking_agent = ContractAgency.get_agent(StakingEscrowAgent, registry=registry)
../../../nucypher/nucypher/blockchain/eth/agents.py:63: in get_agent
    agent = agent_class(registry=registry, provider_uri=provider_uri)
../../../nucypher/nucypher/blockchain/eth/agents.py:102: in __init__
    use_proxy_address=self._forward_address)
../../../nucypher/nucypher/blockchain/eth/interfaces.py:464: in get_contract_by_name
    proxy_live_target_address = proxy_contract.functions.target().call()
../../../../.local/share/virtualenvs/nucypher-monitor-Xewuu8ce/lib/python3.7/site-packages/web3/contract.py:904: in call
    **self.kwargs
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

web3 = &lt;web3.main.Web3 object at 0x7f169853d3c8&gt;
address = &apos;0xBc6297c0781C25A9Bc44eEe22181C98a30DC0229&apos;, normalizers = ()
function_identifier = &apos;target&apos;
transaction = {&apos;to&apos;: &apos;0xBc6297c0781C25A9Bc44eEe22181C98a30DC0229&apos;}
block_id = &apos;latest&apos;
contract_abi = [{&apos;constant&apos;: True, &apos;inputs&apos;: [], &apos;name&apos;: &apos;previousTarget&apos;, &apos;outputs&apos;: [{&apos;name&apos;: &apos;&apos;, &apos;type&apos;: &apos;address&apos;}], ...}, {&apos;cons...stant&apos;: False, &apos;inputs&apos;: [{&apos;name&apos;: &apos;_testTarget&apos;, &apos;type&apos;: &apos;address&apos;}], &apos;name&apos;: &apos;verifyState&apos;, &apos;outputs&apos;: [], ...}, ...]
fn_abi = {&apos;constant&apos;: True, &apos;inputs&apos;: [], &apos;name&apos;: &apos;target&apos;, &apos;outputs&apos;: [{&apos;name&apos;: &apos;&apos;, &apos;type&apos;: &apos;address&apos;}], ...}
args = (), kwargs = {}
call_transaction = {&apos;data&apos;: &apos;0xd4b83992&apos;, &apos;to&apos;: &apos;0xBc6297c0781C25A9Bc44eEe22181C98a30DC0229&apos;}
return_data = HexBytes(&apos;0x&apos;), output_types = [&apos;address&apos;]
is_missing_code_error = True
msg = &apos;Could not transact with/call contract function, is contract deployed correctly and chain synced?&apos;

    def call_contract_function(
            web3: &apos;Web3&apos;,
            address: ChecksumAddress,
            normalizers: Tuple[Callable[..., Any], ...],
            function_identifier: Union[str, Type[FallbackFn]],
            transaction: TxParams,
            block_id: BlockIdentifier=None,
            contract_abi: ABI=None,
            fn_abi: ABIFunction=None,
            *args: Any,
            **kwargs: Any) -&gt; Sequence[Any]:
        &quot;&quot;&quot;
        Helper function for interacting with a contract function using the
        `eth_call` API.
        &quot;&quot;&quot;
        call_transaction = prepare_transaction(
            address,
            web3,
            fn_identifier=function_identifier,
            contract_abi=contract_abi,
            fn_abi=fn_abi,
            transaction=transaction,
            fn_args=args,
            fn_kwargs=kwargs,
        )
    
        if block_id is None:
            return_data = web3.eth.call(call_transaction)
        else:
            return_data = web3.eth.call(call_transaction, block_identifier=block_id)
    
        if fn_abi is None:
            fn_abi = find_matching_fn_abi(contract_abi, web3.codec, function_identifier, args, kwargs)
    
        output_types = get_abi_output_types(fn_abi)
    
        try:
            output_data = web3.codec.decode_abi(output_types, return_data)
        except DecodingError as e:
            # Provide a more helpful error message than the one provided by
            # eth-abi-utils
            is_missing_code_error = (
                return_data in ACCEPTABLE_EMPTY_STRINGS and
                web3.eth.getCode(address) in ACCEPTABLE_EMPTY_STRINGS
            )
            if is_missing_code_error:
                msg = (
                    &quot;Could not transact with/call contract function, is contract &quot;
                    &quot;deployed correctly and chain synced?&quot;
                )
            else:
                msg = (
                    &quot;Could not decode contract function call {} return data {} for &quot;
                    &quot;output_types {}&quot;.format(
                        function_identifier,
                        return_data,
                        output_types
                    )
                )
&gt;           raise BadFunctionCallOutput(msg) from e
E           web3.exceptions.BadFunctionCallOutput: Could not transact with/call contract function, is contract deployed correctly and chain synced?

../../../../.local/share/virtualenvs/nucypher-monitor-Xewuu8ce/lib/python3.7/site-packages/web3/contract.py:1454: BadFunctionCallOutput</failure></testcase></testsuite></testsuites>